<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self'; style-src 'self'; img-src 'self' data: https://www.google.com https://*.gstatic.com; connect-src 'self';">
  <title>OS1NT R3P0 ‚Äî Blog</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico" />
  <link rel="stylesheet" href="assets/css/styles.css" />
  <link rel="stylesheet" href="assets/css/blog-styles.css" />
</head>
<body>
  <header class="site-header">
    <div class="header-inner">
      <a class="home" href="index.html" aria-label="Back to OSINT links">
        <span aria-hidden="true">üè†</span>
      </a>

      <div class="brand">
        <img src="assets/images/logo.png" alt="OS1NT R3P0 Logo" class="brand-mark" />
        <div class="brand-text">
          <h1>OS1NT R3P0</h1>
          <p>Field Notes &amp; Stories</p>
        </div>
      </div>

      <div class="toolbar">
        <div class="search" role="search">
          <div class="icon" aria-hidden="true">‚åï</div>
          <input id="post-search" type="search" placeholder="Search the blog‚Ä¶" aria-label="Search blog posts" />
          <button id="post-search-clear" class="search-clear" type="button" aria-label="Clear search" hidden>‚úï</button>
        </div>
        <div class="pill" aria-live="polite">
          <span>Posts</span> <b id="post-count">0</b>
        </div>
      </div>
    </div>
  </header>

  <main class="wrap">
    <section class="hero-card blog-hero">
      <h2>Investigator's Log</h2>
      <p class="muted">
        Long-form breakdowns, quick wins, and lessons learned from working through OSINT cases, tooling experiments, and verification drills.
      </p>
      <div class="stack">
        <a class="btn primary" href="mailto:info@os1nt.com?subject=OS1NT%20Blog%20Subscription">Subscribe</a>
        <a class="btn" href="index.html">Browse the tools</a>
      </div>
    </section>

    <section class="blog-feed" aria-label="Blog posts">

      <!-- NEW POST: TINDER OSINT -->
      <article class="card post-card">
        <div class="card-head">
          <div class="card-title">
            <h2>Tinder OSINT: extracting profile data from network traffic</h2>
            <div class="post-meta">
              <span>Published 23 January 2026</span>
              <span>8 min read</span>
              <span>By OS1NT R3P0</span>
            </div>
          </div>
          <button class="btn small" type="button">Bookmark</button>
        </div>

        <div class="card-body">
          <p>Tinder is a mobile-first dating application with limited traditional OSINT surface. However, analysts can still extract meaningful information by examining network traffic sent to the mobile or web client.</p>

          <h3>Data access and collection</h3>
          <p>To conduct analysis, use a browser's Network Inspection tool or a web proxy such as Fiddler or Proxyman. During normal browsing, the application preloads profile data through API responses. One commonly observed response is a <code>core.json</code> file containing up to 15 profile cards loaded in advance.</p>

          <p>This process does not require interaction with the profiles themselves. The data arrives automatically as part of the application's performance optimization.</p>

          <h3>Identifiers and metadata</h3>
          <p>Each profile loads with multiple internal identifiers, including:</p>
          <ul>
            <li>A MongoDB ObjectId, which encodes the user's registration timestamp.</li>
            <li>A secondary internal numeric identifier used by the platform.</li>
            <li>A content hash linked to profile state.</li>
          </ul>
            <figure>
            <img src="blogres/user_bio.png" alt="Basic bio in core file" />
            <figcaption class="muted">MongoDB ObjectID and basic bio in core.json</figcaption>
            </figure>
          <p>Together, these identifiers allow analysts to infer account age, correlate profiles across datasets, and distinguish between newly created and long-standing accounts.</p>
            <h3>Determine Tinder profile's registration date</h3>
            <p>A MongoDB ObjectId is a 24-character hexadecimal string. Its first 8 characters represent a Unix timestamp (seconds since 1 January 1970).</p>

            <p><b>Analytical steps:</b></p>
            <ol>
              <li>Take the first 8 hexadecimal characters of the ObjectId.</li>
              <li>Convert that value from hexadecimal to decimal.</li>
              <li>Interpret the result as a Unix timestamp (UTC).</li>
            </ol>

            <p>This allows analysts to determine when a Tinder account was created, even if the platform does not display that information to users.</p>

            <p><b>Example logic (conceptual):</b></p>
            <ul>
              <li>ObjectId: <code>5a7718e8f01e5f122e50061f</code></li>
              <li>First 8 characters: <code>5a7718e8</code></li>
              <li>Hex ‚Üí decimal ‚Üí Unix timestamp</li>
              <li>Result: account creation date in UTC</li>
            </ul>

            <p>This technique is reliable because MongoDB generates ObjectIds server-side and embeds the timestamp by design.</p>
          <h3>Personal and profile attributes</h3>
          <p>The captured data typically includes:</p>
          <ul>
            <li>First name</li>
            <li>Birth date, or an explicitly marked fuzzy birth date when the user restricts visibility</li>
            <li>Bio text and badges</li>
            <li>Lifestyle and personality descriptors, such as communication style, habits, and relationship intent</li>
            <li>Distance information, revealing approximate geographic proximity at the time of capture</li>
          </ul>
          <p>Even when some fields appear hidden in the user interface, they often remain present in the underlying API response.</p>

          <h3>Images and biometric metadata</h3>
          <p>Profile photos arrive in multiple processed resolutions for display. In addition, the data frequently references an original, unprocessed high-resolution image hosted on Tinder's content delivery infrastructure.</p>

          <p>Access to these originals relies on session-specific signed URLs. While the links expire, they allow full-resolution viewing without authentication as long as the session key remains valid.</p>

          <p>The metadata also reveals automated image handling:</p>
          <ul>
            <li>Face detection bounding boxes</li>
            <li>Cropping coordinates</li>
            <li>Indicators showing algorithmic processing</li>
          </ul>
          <p>This information confirms that images undergo server-side facial analysis before delivery.</p>

          <h3>Practical OSINT value</h3>
          <p>Without interacting with users or bypassing controls, network traffic analysis can reveal:</p>
          <ul>
            <li>Account creation timelines</li>
            <li>Consistency or obfuscation of age data</li>
            <li>Behavioral and lifestyle indicators</li>
            <li>High-resolution imagery and biometric processing artifacts</li>
            <li>Differences between displayed privacy settings and backend data exposure</li>
          </ul>

          <div class="tag-list" aria-label="Tags">
            <span class="chip"><b>OSINT</b></span>
            <span class="chip"><b>Network Analysis</b></span>
            <span class="chip"><b>API</b></span>
            <span class="chip"><b>Dating Apps</b></span>
            <span class="chip"><b>Tradecraft</b></span>
          </div>
        </div>
      </article>

      <!-- NEW POST: FAVICON SEARCHES -->
      <article class="card post-card">
        <div class="card-head">
          <div class="card-title">
            <h2>Favicon hash searches: finding related infrastructure fast</h2>
            <div class="post-meta">
              <span>Published 23 December 2025</span>
              <span>10 min read</span>
              <span>By OS1NT R3P0</span>
            </div>
          </div>
          <button class="btn small" type="button">Bookmark</button>
        </div>

        <div class="card-body">
          <p>Favicon searches allow OSINT analysts to identify servers that share the same website icon, even when domains, IP addresses, or hosting providers change. By hashing a favicon and querying platforms such as Shodan, analysts can uncover related infrastructure, shadow environments, and reused panels.</p>

          <figure>
            <img src="blogres/Favicon.png" alt="Example favicon used for hash searches" />
            <figcaption class="muted">Example favicon used to generate a MurmurHash3 fingerprint for search.</figcaption>
          </figure>

          <h3>Why favicon searches matter</h3>
          <p>Favicons are rarely treated as sensitive assets. Organizations often reuse the same icon across production systems, staging environments, and administrative interfaces. While DNS records and IP addresses change frequently, favicons often remain static, making them a reliable pivot point.</p>


          
          <h3>How favicon hashing works</h3>
          <p>The process is straightforward. First, collect the favicon file, commonly located at <code>/favicon.ico</code>.</p>
          <p>Next, generate a hash of the file contents. Shodan indexes favicons using a MurmurHash3 (mmh3) value derived from the favicon bytes. You can use tools like <a href="https://faviconhasher.codejavu.tech/" target="_blank" rel="noopener noreferrer">Favicon Hasher</a> to generate the mmh3 hash. Finally, search that hash to identify other hosts serving the same icon.</p>

          <div class="code">
http.favicon.hash:123456789
          </div>

        <figure>
            <img src="blogres/shodan_favicon_search.png" alt="Shodan favicon hash search results" />
            <figcaption class="muted">Shodan results for a favicon hash query showing matched hosts and metadata.</figcaption>
        </figure>

          <h3>Refining searches in Shodan</h3>
          <p>Analysts can combine favicon hashes with additional filters to reduce noise and prioritize results.</p>

          <div class="code">
http.favicon.hash:123456789 country:DE<br>
http.favicon.hash:123456789 org:"Example Corp"<br>
http.favicon.hash:123456789 port:443
          </div>

          <h3>Practical OSINT use cases</h3>
          <p><b>Attack surface mapping:</b> Starting from a single known website, favicon searches often reveal staging servers, legacy portals, and exposed administrative interfaces that do not appear in DNS inventories.</p>

          <p><b>Phishing and fraud investigations:</b> Phishing kits frequently reuse icons and web templates. A favicon hash can link multiple domains and hosting providers back to the same campaign.</p>

          <p><b>Incident response scoping:</b> When responders identify one exposed system, favicon searches help determine whether other internet-facing systems share the same interface and may require remediation.</p>

          <h3>Limitations to keep in mind</h3>
          <p>Favicon searches can produce false positives, particularly when vendors ship default icons with widely deployed products. Adversaries can also change favicons easily. Analysts should always validate results using supporting indicators such as TLS certificates, HTML titles, response headers, and hosting patterns.</p>

          <div class="tag-list" aria-label="Tags">
            <span class="chip"><b>OSINT</b></span>
            <span class="chip"><b>Infrastructure</b></span>
            <span class="chip"><b>Shodan</b></span>
            <span class="chip"><b>Tradecraft</b></span>
          </div>
        </div>
      </article>

    </section>

    <footer class="footer">
      <span class="muted">¬© OS1NT ‚Ä¢ Field Notes</span>
    </footer>
  </main>

  <script src="assets/js/blog-scripts.js" defer></script>
</body>
</html>
